https://www.bilibili.com/video/BV15D4y1U7j5

教程 - 第一讲
1.导入的像素画会默认应用滤镜，所以会模糊，需要将其filter属性去除   03:47
2.由于像素风游戏界面较小，最好将摄像头长宽重新调整为320*180 , 测试窗口要改成1280*720 ， 拉伸模式设置为2D        07:26
3.godot通过树状节点控制物体关系，每个节点都有一个基坐标点，比如🗡节点要挂载在人物节点上，这样就会跟随人物移动    11:00
4.人物节点可以使用KinematicBody2D，staticBody2D通常用于游戏中不会移动的物体，RigidBody2D使用于物理运动的刚体，KinematicBody2D一般用于代码操控的物理碰撞体          11:22
5.KinematicBody2D创建后没有任何碰撞形状、像素贴图，所以要添加一个sprite挂载在其身上(sprite就是能播放像素贴图的载体)   13:21
6.sprite加载的像素贴图通常是一个N行N列的图片，每一列都可理解为一帧(一个动作)，可以通过Animation-Hframes/Vframes来调节这个像素贴图的N行N列，通过Animation-frame调节其当前显示的帧     14:00
7.我们在鼠标点击移动人物节点的时候，可能会点到人物节点的sprite节点，如果这时候移动，sprite就会相对于人物节点(基点)移动。点击视频中的按钮来控制子节点不可选中   15:26
8.为了控制人物节点，我们需要添加脚本(.gd文件)，脚本中的第一行(extends ...)就代表继承哪个节点类，后面就能使用其所有功能  16:00
9.如果要隐藏3D、商店功能，可通过编辑器-管理编辑器来隐藏   17:13
10.gd脚本功能可以通过右上角帮助按钮查询，_ready函数是当挂载该脚本的节点被加载是必然会运行的init函数(子节点的_ready函数会首先触发) ，另外加'_'的函数都是godot的回调函数  18:48
11.gd脚本_physics_process(delta)函数是个物理引擎更新频率回调的函数，delta参数代表上一帧花费时间     20:00

教程 - 第二讲
1.关于人物移动脚本的编写    00:27

教程 - 第三讲
1.添加碰撞体。人物节点必要的子节点除了像素贴图，还有碰撞形状CollisionShape2D  06:56
2.由于之前设置了子项不可选择，这里如果要单独移动胶囊型碰撞形状，可以按下ALT(并开启像素吸附)   08:33
3.碰撞体可以把走路碰撞体与伤害检测碰撞体区分开，这里设置走路碰撞体   09:11
4.开始创建地图中不会运动的碰撞体staticBody2D，为其添加自定义的碰撞形状CollisionPolygan2D(打开自动吸附)   10:22
5.如果想在debug的时候看到上述5中绘制的碰撞形状，打开调试-显示碰撞区域   11:43

教程 - 第四讲
1.如果有重复利用的节点，可以将其导出为一个场景(类似于一个类)。在导出为场景后，以后所有改动需要在场景里修改。另外一点，在导出的场景，最好把其transform置为0，0    02:12
2.同样，比如想做一个树的场景，那可以和人物一样作出一个有贴图和碰撞的staticBody2D    05:37
3.关于根节点为什么要选择Node2D，第一当根节点的基点被拖动时其他所有2D子节点都会跟着一起动(Node节点没有Transform属性)，第二在将场景放入根节点时落点为鼠标点     07:20
4.如果不想让某个节点移动，则可以直接锁定   09:03
5.第一讲第三个问题，如果想把🗡相对人物不移动，则可以在人物场景中加入🗡     09:29
6.如果希望每个场景有深度，可以将根节点修改为Ysort类型，这种类型会根据场景的y轴来设置其深度，y轴越大的场景就会显示在上一层图层(场景的y值就是每个场景的基点位置)    12:00
7.人物和场景的基点最好在其脚部   13:40

教程 - 第五讲
1.为了让人物节点的像素贴图切换，需要在人物节点下加一个动画节点AnimationPlayer(一般动作每帧0.1秒播放时间)    01:20
2.可以选择一个动画在游戏加载时自动播放  10:37

教程 - 第六讲
1.要播放AnimationPlayer节点的动画，除了使用脚本控制，还能使用一个AnimationTree(动画树)的子节点  00:45
2.AnimationTree需要先添加一个Anim Player，即第五讲中新增的动画节点AnimationPlayer 。还需要指定一个Tree Root(动画树的结构方式) ，这里选用状态机(AnimationNodeStateMachine) 01:31
3.刚选完Tree Root，AnimationTree会有报错警告(未激活)，则设置Active为打开   02:19
4.在AnimationTree中插入两个AnimationPlayer节点的动画，可以在两个动画之间建立播放关系，如果希望播完一个动画后立即播放另一个动画，可以设置Auto Advance打开、Switch Mode设置为AtEnd     03:59
5.为了将人物节点脚本中的键盘方向与动画树连接起来，我们实际上需要在动画树中新建一个BlendSpace2D(他需要将几个动画放置到一个X-Y平面上，Blend就是一个二维向量，可以在脚本中将键盘方向设置为该Blend，动画树即可播放对应动画)      05:17
6.BlendSpace2D的具体设置动画方式     06:00
7.记得把混合方式修改为虚线(根据Blend挑选最为接近的动画)，实线为补间动画(常用于骨骼动画，因为可以通过运动学反算两个状态之间其他状态的运动关节角度)     09:00
8.如果要通过点选Blend，使其播放对应动画，需要先设置Auto Advance打开、并播放AnimationTree中对应的BlendSpace2D动画
9.在设置完成BlendSpace2D后记得将其初始Blend设置为(0,0)     10:15
10.*多个状态机中间一定要设置过渡模式，否则在游戏中状态机不会切换到最终模式(比如正在奔跑，突然停下来，但是状态机仍处于奔跑状态)，像本例必须添加从Run回到Idle的过渡模式，并且设置Auto Advance打开、Switch Mode设置为Immediate 12:00
11.关于如何在脚本中控制AnimationTree的Blend          14:50
12.*AnimationTree需要设置一个初始的动画状态，否则游戏中就不能播放动画了。其次，要关闭AnimationPlayer节点中的初始动画状态(因为会和AnimationTree的初始状态冲突)     16:22
13.我们要学会怎么用脚本设置AnimationTree当前的状态机(需要获取AnimationTree的playback属性，该属性实际上就是AnimationTree里状态机的根句柄)，以实现在不同动画状态之间切换    18:13
14.使用状态机的根句柄(playback属性)的travel函数，可以控制状态机的状态    20:04
15.*一个技巧，为了解决人物45°行走的时候，Run动画会默认选择向上或向下，我们可以将Blend的坐标值调整一下   21:47

教程 - 第七讲
1.YSort不适合背景地图   00:43
2.背景贴图也使用一个Sprite节点控制，将背景贴图移入Sprite的Texture属性中(以基点为贴图左上角需要关闭Offset-Centered属性)    01:30
3.为了实现背景贴图的平铺功能，启用Region-Enabled属性(此刻下方出现'纹理区域'的窗口)，节点将显示选定的纹理区域(吸附模式选择后更容易选取)。然后素材导入界面需要将Flags-Repeat打开   01:42
4.*上述平铺贴图只适合像草坪这样重复且单一的背景图，但如果是一些复杂的背景贴图比如山体等，则可以采用TileMap   07:34
5.*TileMap需要先通过Cell-Size属性设置格子大小，TileSet属性里添加新的TileSet(双击后下方出现'图块集'窗口并进入)，将复杂的背景贴图拉入'图块集'窗口便可以开始编辑纹理   08:06
6.*'图块集'窗口右上角可以添加自动图块，打开吸附并显示网格功能，网格大小通过Snap Options-Step属性控制，然后就能通过滑动选取必要的纹理块(至此已经可以贴图，但贴图时并不能自动选择当前需要贴哪张图)    09:51
7.*为了解决自动选择贴图块的问题(单一图块不需要自动选择贴图块，但是不方便)，采用位掩码模式。首先将Select Tile-Autotile Bitmask属性设置为3x3(minimal) 12:00  随后按视频中的方式设置掩码 19:05
8.具体贴图时每个图块的大小需要通过Select Tile-Subtile Size属性设置    12:28

教程 - 第八讲
1.TileMap添加碰撞属性，可以使用快捷键Shift+R，然后点击图块  08:22

教程 - 第九讲
1.AnimationTree虽然实现了状态机，但是这个状态机是连续运动的状态改变。但是由于脚本需要在离散时间内实时控制动画，所以仍要在每个离散时间点决定当前应该播放的动画状态，这里需要学会怎么使用脚本写动画的状态机  03:56
2.如何将上下左右键位更改为WSAD，打开settings-Input Map   12:14
3.要增加一个键位，比如攻击 12:38
4.动画帧之间可以插入信号调用  19:51

教程 - 第十讲
1.如果想给一类物体编组，但是又不想使其失去YSort属性，则可以将其编组后的整体也重新定义为YSort节点  01:32
2.关于如何创建一个场景(.tscn后缀的文件)   05:23
3.如果要复制节点，可以使用Ctrl+D的快捷键   06:50
4.动画实现除了上面使用过的AnimationPlayer、AnimationTree，还能使用AnimatedSprite(用于实现简单的动画)。另外一点，效果节点最好和物体节点分成两个场景制作，比如此处的叶子节点和叶子凋零的效果节点(这样效果可以复用)  09:03
5.如果只想测试某个子场景，则可以在子场景中点击右上角运行图标 13:44
6.在上一讲中已经使用过在动画帧中插入信号，但实际上godot的节点类中都自带了些默认的信号并在某个特殊时间点发出信号，我们可以利用这些信号链接到我们自己的槽函数上  16:38
7.游戏编辑时有一个节点树(本地)，但是游戏运行时实际上有另一个节点树(远程)  24:13

*教程 - 第十一讲
1.为了实现伤害检测框(Hurtboxes)，和攻击检测框(Hitboxes)，需要新建一个Area2D节点(该节点拥有一个信号，有外界物体进入该区域，就会出发此信号)  02:43
2.如果想往场景中添加另一个场景，可以点击“实例化子场景”按钮  05:00
3.如果要在场景中访问某个子场景的子节点，则可以右键选择“子节点可编辑”   05:27
4.有时候我们希望在某个场景内创建一个相对坐标点，这样其他的子节点就能挂载到该节点上(实现类似于旋转的操作，godot中Transform属性是基于挂载点的)，可以使用Position2D节点(本质上就是Node2D节点，但是拥有可显示的十字轴)    10:26
5.在动画AnimationPlayer中甚至能设置各子节点的属性值。这里我们要在动画的各个帧中使能/关闭攻击检测框的区域   16:24
6.*godot里面有个层级的功能，设置了层级就能方便地控制各个物体之间的碰撞关系，如果要设置各个层级，可通过Project settings - Layer Names -2d Physics设置     19:55
7.*关于层级的设置，可以学习up主的。   21:08
8.*具体的每个物体或者节点的碰撞层级设置，可以进入该节点属性 - Collision进行设置(该节点必须拥有CollisionShape2D)。分为Layer和Mask两个层级，Layer层表示当前节点所存在的层级，Mask层表示当前节点能影响到哪些层级     21:58

教程 - 第十三讲
1.AnimatedSprite可以当作简单敌人的sprite+动画   03:40
2.在2D游戏中，飞行敌人的碰撞区域要设定在地面上(可以想象飞行敌人是站在地上的一根长管子)   04:55
3.之前将伤害检测框(Hurtboxes)，和攻击检测框(Hitboxes)单独变成一个父类的好处显现出来了，因为每个敌人我们都需要实现这两个区域，要用的时候只需要继承即可   08:06
4.计算两个碰撞区域之间的中心点向量差，以实现敌人击退效果。他的计算击退向量方法不太好(根本不需要为剑新建脚本)，但是可以学习如何传参(在剑身上挂载一个脚本，并定义一个全局变量，在触发碰撞时会作为信号的参数传给被击打脚本)  16:18

教程 - 第十四讲
1.如果要在程序运行时修改export的变量，可直接在运行游戏的时候修改   07:47
2.onready前缀的变量，会在执行_ready()函数时才赋值    08:38

教程 - 第十五讲
1.如果要设置动画的初始状态，可以设置其初始blend值  00:52
2.特效图设置偏移的时候记得不是去设置transform，而是offset(前者只是移动特效场景的根节点位置，但由于特效添加时我们会设置其global_position到一个人物或敌人节点上，所以根节点位置会被覆盖。而后者可以设置播放动画的相对位置) 09:48

教程 - 第十六讲
1.关于实现一个击中特效(个人认为可以做的和叶子凋零特效一样，在需要被使用的时候实例化一下就可以了)  00:24
2.敌人若想实现检测玩家，需要新建一个玩家检测框(Detectboxes)，与上述讲的伤害检测框(Hurtboxes)，和攻击检测框(Hitboxes)都是Area2D节点  09:41

教程 - 第十七讲
1.如果要新建一个场景，且继承一个已有的场景，则可以点击场景-新建继承场景   01:01
2.*在收到攻击后，需要添加一个硬直时间(无敌)，这样有两个好处，第一受伤者不会瞬间死亡，第二godot能重置碰撞状态(不然就会像视频里一样，在攻击了一次后虽然碰到了但是仍不会掉血)  07:19

教程 - 第十八讲
1.Control节点和UI有关，这里开始讲述如何开发用户的血量UI界面(Control节点的position与其他节点不同)   00:55
2.为了显得更简洁，我们这边将Control作为场景的根节点，并放入一个Label子节点   03:53
3.要实现血量UI中的心心变化，可以用一些取巧的办法，亮心与暗心分别设立一个TextureRect节点   12:00
4.TextureRect节点如果要将像素重复平铺，需要将Strentch Mode属性调整为Tile  12:48
5.TextureRect节点如果希望rect大小能够比像素本身还要小，需要开启Expand属性  24:00

教程 - 第二十讲
1.新建一个附着在玩家身上的相机，添加Camera2D节点，并且需要设置current属性(将主镜头设置为该Camera2D节点)   00:40
2.为了使血量UI能跟随相机运动，需要用到CanvasLayer节点(该节点会跟随主镜头运动)，将血量UI移动到该CanvasLayer节点下即可   02:52
3.为了让镜头不抖动，我们可以设置镜头属性smoothing   03:25
4.为了让镜头不抖动，除了smoothing属性，比如项目设置-Rendering-2d-Use Gpu Pixel Snap(开启像素吸附)   04:30
5.为了解决死亡后，镜头会回到初始起点，这里我们需要把Camera2D节点放置到根节点下，然后在玩家节点下添加一个RemoteTransform2D的子节点(需要将Camera2D节点加载到其Remote Path属性之下)    05:25

教程 - 第二十二讲
1.音乐播放使用AudioStreamPlayer节点(可以理解为一个音响，另外AudioStreamPlayer2D具有距离越远音效越弱的特点)。实际使用的时候只需要将音效加入到动画的帧中间，添加"音频播放轨道"，并插入播放音效的关键帧即可   00:52
2.注意如果要在动画中播放音效，则音效不要直接拖放到AudioStreamPlayer节点中，而是拖放到关键帧中。如果要在Effect中添加，则可以将音效直接拖放到AudioStreamPlayer节点中，并勾选自动播放  03:15
3.Hitbox可能在初始状态下就开启，为解决这个bug，我们可以在IdleDown动画中禁用Hitbox即可   05:36
4.*关于着色器的用法  13:00

教程 - 第二十三讲
1.关于限制镜头移动，当地图有界限时可以修改Limit属性中的上下左右最大边界值，这样当玩家走到该处时，镜头就无法再移动了   03:49

GDScript编程细节
1.使用'$'可以获取到脚本节点的子节点    P5.11:38
2.onready var定义初始化时的变量   P5.12:56
3.通过子节点句柄的get方法可以获取到子节点的属性    P6.18:26
4.脚本写动画的状态机  P9.03:56
5._phisics_process(delta)与_process(delta)函数区别(假如要获取最精确的节点位置等属性，使用前者。但是如果不需要获取，则后者能使游戏更流畅) P10.02:29
6.如果要在脚本中注释/取消注释 ，快捷键为Ctrl+K  P10.07:34
7.queue_free()与free()函数的作用，他们都会把节点从项目中移除，但是前者会等这一帧结束后再移除，后者会立即移除(前者考虑到帧内可能还会对该节点做些操作)    P10.07:50
8.*关于如何在脚本中实例化一个场景，以及如何获取根节点，以及如何将实例化的场景放入到根节点    P10.20:06
9.godot支持将资源直接拖入脚本中，转化成路径   P10.21:12
10.获取根节点的第一个场景，使用get_tree().current_scene   P10.25:23
11.想要获取某个物体在根节点中的绝对坐标，可以使用该节点的global_position属性  P10.27:03
12.建立当前场景下所有脚本都能使用的公用变量脚本，以及如何读取与修改这些变量  P14.01:00
13.export的变量可以定义其数据类型  P14.04:42
14.godot社区明确表示了，如果要在一个脚本中设置另一个脚本的变量值，最好是通过调用变量所在脚本设置(setget方法能使外部脚本直接修改变量值时自动转换成调用set get函数)。如果要从下层脚本要控制上层脚本，最好是通过触发信号  P14.11:29
15.如何自定义信号，并链接到指定槽函数  P14.12:25
16.一个场景可以有其自己的脚本，那么当该场景被实例化的时候，其脚本也是相同的。但是如果我纯粹只想让某个脚本继承另一个脚本，那么可以将extends修改为父脚本(也会同时继承父脚本的父类)  20:07
17.用代码写链接信号和槽的connect函数   P15.07:03
18.在代码中加载一个场景类，可以使用load或者preload(预加载即后者，能够集中资源加载避免卡顿)   P15.10:34
19.在代码中获取父节点句柄的方法为直接调用get_parent()，以及静态变量的定义方法为const '变量名' =     P15.12:50
20.body_entered(body)与body_exited(body)函数均能传递正在进出的物体场景句柄  P16.13:05
21.*项目设置-自动加载，此处添加的场景，可以被所有脚本直接调用。作为单例的场景，无需在任何场景中实例化节点，直接使用即可(其信号槽连接必须在代码中写，不能再使用节点中直接连接的方法)   P17.02:00
22.如果在脚本内部使用该脚本自身的setget函数，则需要在设置变量前输入'self.' ，如此调用的时候才会安全进入setget函数   P17.11:52
23.Mornitoring属性能够设置碰撞Layer是否开启，Monitorable属性能够设置碰撞Mask是否开启  P17.15:16
24.有些godot内置属性并不能在信号槽中立即设置，需要使用set_deferred()函数进行设置(该函数将在当前帧结束后设置属性)  P17.20:03
25.godot字符串合并方法，以及如何获取Label的字符串   P18.10:52
26.如何在发送信号时传递参数(注意信号定义时也必须加上参数)   P18.08:18
27.debug模式下能监测游戏运行的性能参数    P19.12:05
28.要获取Timer的剩余时间，可以使用.time_left方法  P21.08:45
29.为了实现在几个int类型中随机获取其中一个值，可以使用list = [a, b]; list.shuffle(); list.pop_front()，即重新洗牌，并获取该向量的第一个，   P21.07:10
30.想要获取向量，可以使用distance_to()方法   P21.15:47

背景贴图制作细节
1.*复杂的背景贴图可以使用tilesetter制作(相关内容有空的时候可以看下作者的视频)    P7.09:29